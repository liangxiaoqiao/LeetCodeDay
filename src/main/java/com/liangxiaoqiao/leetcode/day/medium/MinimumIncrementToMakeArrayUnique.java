package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 945
 * title: Minimum Increment to Make Array Unique
 * href: https://leetcode.com/problems/minimum-increment-to-make-array-unique
 * desc: Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.\nReturn the least number of moves to make every value in A unique.\n  Example 1:\nInput: [1,2,2]\nOutput: 1\nExplanation:  After 1 move, the array could be [1, 2, 3].\nExample 2:\nInput: [3,2,1,2,1,7]\nOutput: 6\nExplanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].\nIt can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n  Note:\n0 <= A.length <= 40000\n0 <= A[i] < 40000\n
 * <p>
 * 中文
 * 序号: 945
 * 标题： 使数组唯一的最小增量
 * 链接： https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique
 * 描述： 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。\n返回使 A 中的每个值都是唯一的最少操作次数。\n示例 1:\n输入：[1,2,2]\n输出：1\n解释：经过一次 move 操作，数组将变为 [1, 2, 3]。\n示例 2:\n输入：[3,2,1,2,1,7]\n输出：6\n解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\n可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\n提示：\n0 <= A.length <= 40000\n0 <= A[i] < 40000
 * <p>
 * acceptance: 44.6%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class MinimumIncrementToMakeArrayUnique {
    public int minIncrementForUnique(int[] A) {
        return 0;
    }
}