package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 934
 * title: Shortest Bridge
 * href: https://leetcode.com/problems/shortest-bridge
 * desc: In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)\nNow, we may change 0s to 1s so as to connect the two islands together to form 1 island.\nReturn the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)\n  Example 1:\nInput: [[0,1],[1,0]]\nOutput: 1\nExample 2:\nInput: [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\nExample 3:\nInput: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n  Note:\n1 <= A.length = A[0].length <= 100\nA[i][j] == 0 or A[i][j] == 1\n
 * <p>
 * 中文
 * 序号: 934
 * 标题： 最短的桥
 * 链接： https://leetcode-cn.com/problems/shortest-bridge
 * 描述： 在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）\n现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。\n返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）\n  示例 1：\n输入：[[0,1],[1,0]]\n输出：1\n示例 2：\n输入：[[0,1,0],[0,0,0],[0,0,1]]\n输出：2\n示例 3：\n输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n输出：1\n  提示：\n1 <= A.length = A[0].length <= 100\nA[i][j] == 0 或 A[i][j] == 1\n
 * <p>
 * acceptance: 46.0%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class ShortestBridge {
    public int shortestBridge(int[][] A) {
        return 0;
    }
}