package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 947
 * title: Most Stones Removed with Same Row or Column
 * href: https://leetcode.com/problems/most-stones-removed-with-same-row-or-column
 * desc: On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.
 * Now, a move consists of removing a stone that shares a column or row with another stone on the grid.
 * What is the largest possible number of moves we can make?
 * Example 1:
 * Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
 * Output: 5
 * Example 2:
 * Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
 * Output: 3
 * Example 3:
 * Input: stones = [[0,0]]
 * Output: 0
 * Note:
 * 1 <= stones.length <= 1000
 * 0 <= stones[i][j] < 10000
 * <p>
 * 中文
 * 序号: 947
 * 标题： 移除最多的同行或同列石头
 * 链接： https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column
 * 描述： 在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。\n\n我们最多能执行多少次 move 操作？\n  示例 1：\n输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n输出：5\n示例 2：\n输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n输出：3\n示例 3：\n输入：stones = [[0,0]]\n输出：0\n  提示：\n1 <= stones.length <= 1000\n0 <= stones[i][j] < 10000
 * <p>
 * acceptance: 54.9%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class MostStonesRemovedWithSameRowOrColumn {
    public int removeStones(int[][] stones) {
        return 0;
    }
}