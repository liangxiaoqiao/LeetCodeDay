package com.liangxiaoqiao.leetcode.day.medium;


import com.liangxiaoqiao.leetcode.day.pojo.TreeNode;

import java.util.List;
    
/*
 * English
 * id: 95
 * title: Unique Binary Search Trees II
 * href: https://leetcode.com/problems/unique-binary-search-trees-ii
 * desc: Given an integer n, generate all structurally unique BST\'s (binary search trees) that store values 1 ... n.\nExample:\nInput: 3\nOutput:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\nExplanation:\nThe above output corresponds to the 5 unique BST\'s shown below:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3
 * <p>
 * 中文
 * 序号: 95
 * 标题： 不同的二叉搜索树 II
 * 链接： https://leetcode-cn.com/problems/unique-binary-search-trees-ii
 * 描述： 给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。\n示例:\n输入: 3\n输出:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释:\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3
 * <p>
 * acceptance: 37.9%
 * difficulty: Medium
 * private: False
 */


//TODO init

/*
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class UniqueBinarySearchTreesIi {
    public List<TreeNode> generateTrees(int n) {
        return null;
    }
}

