package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 1053
 * title: Previous Permutation With One Swap
 * href: https://leetcode.com/problems/previous-permutation-with-one-swap
 * desc: Given an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.
 * Example 1:
 * Input: [3,2,1]
 * Output: [3,1,2]
 * Explanation: Swapping 2 and 1.
 * Example 2:
 * Input: [1,1,5]
 * Output: [1,1,5]
 * Explanation: This is already the smallest permutation.
 * Example 3:
 * Input: [1,9,4,6,7]
 * Output: [1,7,4,6,9]
 * Explanation: Swapping 9 and 7.
 * Example 4:
 * Input: [3,1,1,3]
 * Output: [1,3,1,3]
 * Explanation: Swapping 1 and 3.
 * Note:
 * 1 <= A.length <= 10000
 * 1 <= A[i] <= 10000
 * <p>
 * 中文
 * 序号: 1053
 * 标题： 交换一次的先前排列
 * 链接： https://leetcode-cn.com/problems/previous-permutation-with-one-swap
 * 描述： 给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。
 * 如果无法这么操作，就请返回原数组。
 * 示例 1：
 * 输入：[3,2,1]
 * 输出：[3,1,2]
 * 解释：
 * 交换 2 和 1
 * 示例 2：
 * 输入：[1,1,5]
 * 输出：[1,1,5]
 * 解释：
 * 这已经是最小排列
 * 示例 3：
 * 输入：[1,9,4,6,7]
 * 输出：[1,7,4,6,9]
 * 解释：
 * 交换 9 和 7
 * 示例 4：
 * 输入：[3,1,1,3]
 * 输出：[1,3,1,3]
 * 解释：
 * 交换 1 和 3
 * 提示：
 * 1 <= A.length <= 10000
 * 1 <= A[i] <= 10000
 * <p>
 * acceptance: 47.3%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class PreviousPermutationWithOneSwap {
    public int[] prevPermOpt1(int[] A) {
        return null;
    }
}