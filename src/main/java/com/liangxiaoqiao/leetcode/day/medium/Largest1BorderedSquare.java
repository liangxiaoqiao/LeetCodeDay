package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 1139
 * title: Largest 1-Bordered Square
 * href: https://leetcode.com/problems/largest-1-bordered-square
 * desc: Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.
 * Example 1:
 * Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
 * Output: 9
 * Example 2:
 * Input: grid = [[1,1,0,0]]
 * Output: 1
 * Constraints:
 * 1 <= grid.length <= 100
 * 1 <= grid[0].length <= 100
 * grid[i][j] is 0 or 1
 * <p>
 * 中文
 * 序号: 1139
 * 标题： 最大的以 1 为边界的正方形
 * 链接： https://leetcode-cn.com/problems/largest-1-bordered-square
 * 描述： 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。
 * 示例 1：
 * 输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
 * 输出：9
 * 示例 2：
 * 输入：grid = [[1,1,0,0]]
 * 输出：1
 * 提示：
 * 1 <= grid.length <= 100
 * 1 <= grid[0].length <= 100
 * grid[i][j] 为 0 或 1
 * <p>
 * acceptance: 45.6%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class Largest1BorderedSquare {
    public int largest1BorderedSquare(int[][] grid) {
        return 0;
    }
}