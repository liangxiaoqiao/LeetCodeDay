package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 324
 * title: Wiggle Sort II
 * href: https://leetcode.com/problems/wiggle-sort-ii
 * desc: Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\nExample 1:\nInput: nums = [1, 5, 1, 1, 6, 4]\nOutput: One possible answer is [1, 4, 1, 5, 1, 6].\nExample 2:\nInput: nums = [1, 3, 2, 2, 3, 1]\nOutput: One possible answer is [2, 3, 1, 3, 1, 2].\nNote:\nYou may assume all input has valid answer.\nFollow Up:\nCan you do it in O(n) time and/or in-place with O(1) extra space?
 * <p>
 * 中文
 * 序号: 324
 * 标题： 摆动排序 II
 * 链接： https://leetcode-cn.com/problems/wiggle-sort-ii
 * 描述： 给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。\n示例 1:\n输入: nums = [1, 5, 1, 1, 6, 4]\n输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]\n示例 2:\n输入: nums = [1, 3, 2, 2, 3, 1]\n输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]\n说明:\n你可以假设所有输入都会得到有效的结果。\n进阶:\n你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？
 * <p>
 * acceptance: 29.0%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class WiggleSortIi {
    public void wiggleSort(int[] nums) {
    }
}