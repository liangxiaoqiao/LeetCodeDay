package com.liangxiaoqiao.leetcode.day.medium;

    
    import com.liangxiaoqiao.leetcode.day.pojo.TreeNode;
        

/*
 * English
 * id: 889
 * title: None
 * href: None
 * desc: None
 * <p>
 * 中文
 * 序号: 889
 * 标题： 根据前序和后序遍历构造二叉树
 * 链接： https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal
 * 描述： 返回与给定的前序和后序遍历匹配的任何二叉树。\n pre 和 post 遍历中的值是不同的正整数。\n  示例：\n输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n输出：[1,2,3,4,5,6,7]\n  提示：\n1 <= pre.length == post.length <= 30\npre[] 和 post[] 都是 1, 2, ..., pre.length 的排列\n每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。
 * <p>
 * acceptance: 61.5%
 * difficulty: Medium
 * private: False
 */


//TODO init

/*
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */
public class ConstructBinaryTreeFromPreorderAndPostorderTraversal {
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        return null;
    }


}

