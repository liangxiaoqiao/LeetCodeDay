package com.liangxiaoqiao.leetcode.day.medium;


/*
 * English
 * id: 823
 * title: Binary Trees With Factors
 * href: https://leetcode.com/problems/binary-trees-with-factors
 * desc: Given an array of unique integers, each integer is strictly greater than 1.\nWe make a binary tree using these integers and each number may be used for any number of times.\nEach non-leaf node\'s value should be equal to the product of the values of it\'s children.\nHow many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.\nExample 1:\nInput: A = [2, 4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: A = [2, 4, 5, 10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n  Note:\n1 <= A.length <= 1000.\n2 <= A[i] <= 10 ^ 9.
 * <p>
 * 中文
 * 序号: 823
 * 标题： 带因子的二叉树
 * 链接： https://leetcode-cn.com/problems/binary-trees-with-factors
 * 描述： 给出一个含有不重复整数元素的数组，每个整数均大于 1。\n我们用这些整数来构建二叉树，每个整数可以使用任意次数。\n其中：每个非叶结点的值应等于它的两个子结点的值的乘积。\n满足条件的二叉树一共有多少个？返回的结果应模除 10 ** 9 + 7。\n  示例 1:\n输入: A = [2, 4]\n输出: 3\n解释: 我们可以得到这些二叉树: [2], [4], [4, 2, 2]\n示例 2:\n输入: A = [2, 4, 5, 10]\n输出: 7\n解释: 我们可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n  提示:\n1 <= A.length <= 1000.\n2 <= A[i] <= 10 ^ 9.
 * <p>
 * acceptance: 34.4%
 * difficulty: Medium
 * private: False
 */


//TODO init
public class BinaryTreesWithFactors {
    public int numFactoredBinaryTrees(int[] A) {
        return 0;
    }
}