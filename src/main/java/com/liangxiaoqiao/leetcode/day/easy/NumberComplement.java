package com.liangxiaoqiao.leetcode.day.easy;


/*
 * English
 * id: 476
 * title: Number Complement
 * href: https://leetcode.com/problems/number-complement
 * desc: Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\nNote:\nThe given integer is guaranteed to fit within the range of a 32-bit signed integer.\nYou could assume no leading zero bit in the integer’s binary representation.\nExample 1:\nInput: 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\nExample 2:\nInput: 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
 * <p>
 * 中文
 * 序号: 476
 * 标题： 数字的补数
 * 链接： https://leetcode-cn.com/problems/number-complement
 * 描述： 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。\n注意:\n给定的整数保证在32位带符号整数的范围内。\n你可以假定二进制数不包含前导零位。\n示例 1:\n输入: 5\n输出: 2\n解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。\n示例 2:\n输入: 1\n输出: 0\n解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。
 * <p>
 * acceptance: 63.0%
 * difficulty: Easy
 * private: False
 */


//TODO init
public class NumberComplement {
    public int findComplement(int num) {
        return 0;
    }
}