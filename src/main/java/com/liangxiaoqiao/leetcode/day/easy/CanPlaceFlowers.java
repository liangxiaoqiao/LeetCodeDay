package com.liangxiaoqiao.leetcode.day.easy;


/*
 * English
 * id: 605
 * title: Can Place Flowers
 * href: https://leetcode.com/problems/can-place-flowers
 * desc: Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.\nGiven a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: True\nExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: False\nNote:\nThe input array won\'t violate no-adjacent-flowers rule.\nThe input array size is in the range of [1, 20000].\nn is a non-negative integer which won\'t exceed the input array size.
 * <p>
 * 中文
 * 序号: 605
 * 标题： 种花问题
 * 链接： https://leetcode-cn.com/problems/can-place-flowers
 * 描述： 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。\n示例 1:\n输入: flowerbed = [1,0,0,0,1], n = 1\n输出: True\n示例 2:\n输入: flowerbed = [1,0,0,0,1], n = 2\n输出: False\n注意:\n数组内已种好的花不会违反种植规则。\n输入的数组长度范围为 [1, 20000]。\nn 是非负整数，且不会超过输入数组的大小。
 * <p>
 * acceptance: 31.5%
 * difficulty: Easy
 * private: False
 */


//TODO init
public class CanPlaceFlowers {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        return false;
    }
}