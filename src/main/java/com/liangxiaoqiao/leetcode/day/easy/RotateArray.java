package com.liangxiaoqiao.leetcode.day.easy;


/*
 * English
 * id: 189
 * title: Rotate Array
 * href: https://leetcode.com/problems/rotate-array
 * desc: Given an array, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\nNote:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\nCould you do it in-place with O(1) extra space?
 * <p>
 * 中文
 * 序号: 189
 * 标题： 旋转数组
 * 链接： https://leetcode-cn.com/problems/rotate-array
 * 描述： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n示例 1:\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n示例 2:\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n说明:\n尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n要求使用空间复杂度为 O(1) 的原地算法。
 * <p>
 * acceptance: 32.5%
 * difficulty: Easy
 * private: False
 */


//TODO init
public class RotateArray {
    public void rotate(int[] nums, int k) {
    }
}