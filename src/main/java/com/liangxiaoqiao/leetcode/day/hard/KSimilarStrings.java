package com.liangxiaoqiao.leetcode.day.hard;


/*
 * English
 * id: 854
 * title: K-Similar Strings
 * href: https://leetcode.com/problems/k-similar-strings
 * desc: Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.\nGiven two anagrams A and B, return the smallest K for which A and B are K-similar.\nExample 1:\nInput: A = \"ab\", B = \"ba\"\nOutput: 1\nExample 2:\nInput: A = \"abc\", B = \"bca\"\nOutput: 2\nExample 3:\nInput: A = \"abac\", B = \"baca\"\nOutput: 2\nExample 4:\nInput: A = \"aabc\", B = \"abca\"\nOutput: 2\nNote:\n1 <= A.length == B.length <= 20\nA and B contain only lowercase letters from the set {\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'}
 * <p>
 * 中文
 * 序号: 854
 * 标题： 相似度为 K 的字符串
 * 链接： https://leetcode-cn.com/problems/k-similar-strings
 * 描述： 如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。\n给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。\n  示例 1：\n输入：A = \"ab\", B = \"ba\"\n输出：1\n示例 2：\n输入：A = \"abc\", B = \"bca\"\n输出：2\n示例 3：\n输入：A = \"abac\", B = \"baca\"\n输出：2\n示例 4：\n输入：A = \"aabc\", B = \"abca\"\n输出：2\n  提示：\n1 <= A.length == B.length <= 20\nA 和 B 只包含集合 {\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'} 中的小写字母。
 * <p>
 * acceptance: 37.0%
 * difficulty: Hard
 * private: False
 */


//TODO init
public class KSimilarStrings {
    public int kSimilarity(String A, String B) {
        return 0;
    }
}