package com.liangxiaoqiao.leetcode.day.hard;

import java.util.List;

/*
 * English
 * id: 30
 * title: Substring with Concatenation of All Words
 * href: https://leetcode.com/problems/substring-with-concatenation-of-all-words
 * desc: You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\nExample 1:\nInput:\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\nExample 2:\nInput:\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []
 * <p>
 * 中文
 * 序号: 30
 * 标题： 串联所有单词的子串
 * 链接： https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words
 * 描述： 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n  示例 1：\n输入：\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoor\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n示例 2：\n输入：\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]
 * <p>
 * acceptance: 24.6%
 * difficulty: Hard
 * private: False
 */


//TODO init
public class SubstringWithConcatenationOfAllWords {
    public List<Integer> findSubstring(String s, String[] words) {
        return null;
    }
}

