package com.liangxiaoqiao.leetcode.day.hard;


/*
 * English
 * id: 952
 * title: Largest Component Size by Common Factor
 * href: https://leetcode.com/problems/largest-component-size-by-common-factor
 * desc: Given a non-empty array of unique positive integers A, consider the following graph:\nThere are A.length nodes, labelled A[0] to A[A.length - 1];\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\nReturn the size of the largest connected component in the graph.\n  Example 1:\nInput: [4,6,15,35]\nOutput: 4\nExample 2:\nInput: [20,50,9,63]\nOutput: 2\nExample 3:\nInput: [2,3,6,7,4,12,21,39]\nOutput: 8\nNote:\n1 <= A.length <= 20000\n1 <= A[i] <= 100000
 * <p>
 * 中文
 * 序号: 952
 * 标题： 按公因数计算最大组件大小
 * 链接： https://leetcode-cn.com/problems/largest-component-size-by-common-factor
 * 描述： 给定一个由不同正整数的组成的非空数组 A，考虑下面的图：\n有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；\n只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。\n返回图中最大连通组件的大小。\n  示例 1：\n输入：[4,6,15,35]\n输出：4\n示例 2：\n输入：[20,50,9,63]\n输出：2\n示例 3：\n输入：[2,3,6,7,4,12,21,39]\n输出：8\n  提示：\n1 <= A.length <= 20000\n1 <= A[i] <= 100000
 * <p>
 * acceptance: 28.5%
 * difficulty: Hard
 * private: False
 */


//TODO init
public class LargestComponentSizeByCommonFactor {
    public int largestComponentSize(int[] A) {
        return 0;
    }
}